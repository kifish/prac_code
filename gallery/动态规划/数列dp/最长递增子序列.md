



[2,2]
Output
2
Expected
1

```C
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> grow;
        for (int i = 0; i < nums.size(); i++) {
            int x = nums[i];
            vector<int>::iterator it = upper_bound(grow.begin(), grow.end(), x);
            if (it == grow.end()){
                if(grow.size() >= 1 && grow[grow.size() -1] == x)
                    continue;//保证严格递增
                grow.push_back(x);
            }
            else *it = x;
        }
        return grow.size();
    }
};
```


[4,10,4,3,8,9]
Output
4
Expected
3

AC

这种解法在LeetCode上AC了。
https://leetcode.com/problems/longest-increasing-subsequence/submissions/

```c
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        set<int> grow;
        for (int i = 0; i < nums.size(); i++) {
            int x = nums[i];
            if(grow.count(x) != 0)
                continue;
            set<int>::iterator it = upper_bound(grow.begin(), grow.end(), x);
            if (it == grow.end()){
                grow.insert(x);
            }
            else{
                grow.erase(it);
                grow.insert(x);
            }
        }
        return grow.size();
    }
};
```

牛客网上也AC了。
https://www.nowcoder.com/questionTerminal/d83721575bd4418eae76c916483493de

```C
#include <iostream>
#include <iomanip>
#include <cmath>
#include <cstdio>
#include <queue>
#include <cstring>
#include <set>
#include <algorithm>
using namespace std;


int main() {
    int n;
    while (scanf("%d", &n) == 1) {
        set<int> grow;
        for (int i = 0; i < n; i++) {
            int x;
            scanf("%d", &x);
            if(grow.count(x) != 0)
                continue;
            set<int>::iterator it = upper_bound(grow.begin(), grow.end(), x);
            if (it == grow.end()){
                grow.insert(x);
            }
//            else *it = x; stl不支持这么写
            else{
                grow.erase(it);
                grow.insert(x);
            }
        }
        printf("%d\n", grow.size());
    }
    return 0;
}
```


O(nlogn)写法。   
https://codeforces.com/blog/entry/12274

```c
#include <stdio.h>

int a[10001], t[10001], n, l, i;

/**
a -> This is the input, is an array of integers
t -> Each position have the index of the last item in the ith LIS
l -> The last valid position of t
n -> Size of input a
**/

int ceil(int v)
{
    int init = 0, fin = l; ///Start and end for binary search
    while(init < fin-1)
    {
        int m = (init+fin)/2;
        
        if(a[t[m]] >= v)
            fin = m;
        else
            init = m;
    }

    if(a[t[init]] >= v)
        return init;
    return fin;
}

void lis()
{
    r[0] = 1;
    t[0] = 0;
    l = 0;

    for(i=1; i<n; i++)
    {
        if(a[i] > a[t[l]])
            l++, t[l] = i;
        else
            t[ceil(a[i])] = i;
    }
}

```