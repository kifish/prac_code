http://algorithm.openjudge.cn/2018finalsim/1/


```c
#pragma warning(disable : 4996)
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<string>
#include<queue>
#include<map>
#include<set>
#include<cmath>
#include<algorithm>
using namespace std;
const int INF = 0x3fffffff;
const double DINF = 10000000000.0;




set<char> ops = { '*','/','+','-' };

struct Node {
	bool is_num;
	double num;
	char op;
};

vector<Node> the_exp;
vector<Node> exp_buf;


vector<Node> cal(vector<Node> the_exp) {
	if (the_exp.size() <= 2) return the_exp;
	int i = the_exp.size() - 1;
	int j;
	for (j= i; j >= 0; j--) {
		if (the_exp[j].is_num == false)
			break;
	}
	i = j;
	double tmp;
	if (the_exp[i].op == '*')
		tmp = the_exp[i + 1].num * the_exp[i + 2].num;
	else if (the_exp[i].op == '/')
		tmp = the_exp[i + 1].num / the_exp[i + 2].num;
	else if (the_exp[i].op == '-')
		tmp = the_exp[i + 1].num - the_exp[i + 2].num;
	else
		tmp = the_exp[i + 1].num + the_exp[i + 2].num;
	vector<Node> new_exp;
	for (j = 0; j < i; j++) new_exp.push_back(the_exp[j]);
	Node t;
	t.is_num = 1;
	t.num = tmp;
	new_exp.push_back(t);
	for (j = i + 3; j < the_exp.size(); j++){
		new_exp.push_back(the_exp[j]);
	}
	return cal(new_exp);
}
int main(){


	string s;
		while (cin >> s) {
			Node tmp;
			if (s[0] == '*') {
				tmp.is_num = false;
				tmp.op = '*';
			}
			else if (s[0] == '/') {
				tmp.is_num = false;
				tmp.op = '/';
			}
			else if (s[0] == '+') {

				tmp.is_num = false;
				tmp.op = '+';
			}
			else if (s[0] == '-') {

				tmp.is_num = false;
				tmp.op = '-';
			}
			else {

				tmp.is_num = true;
				tmp.num = atof(s.c_str());
			}
			the_exp.push_back(tmp);
		}
		vector<Node> res = cal(the_exp);
		printf("%f\n", res[0].num);
	//while (1);
	return 0;
}
```

模拟上机考试的时候，一开始不记得逆波兰表达式的规则，且忘记了vector如何切片。还好时限卡的不是很严。






