

https://www.nowcoder.com/practice/30a0153649304645935c949df7599602?tpId=69&tqId=29654&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fhust-kaoyan%2Fquestion-ranking&tPage=1



```python

class Node(object):
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None


"""
二叉排序树，左子树小于等于根，右子树大于等于根。递归建立。
中序遍历即可得不递减序列。


前序遍历  根 左 右
中序遍历  左 根 右
后序遍历  左 右 根

左子树永远先于右子树

"""


class BinaryTree(object):
    def __init__(self):
        self.root = None

    # 用递归可能不好实现返回插入节点的父节点
    def insert(self,val):
        if not self.root:
            self.root = Node(val)
            return -1

        # 实际上这里没必要用queue,只需保留一个前驱node和对应的方向即可
        queue = []
        queue.append((self.root,'left')) # 这里right换成left也是一样的
        while queue:
            if not queue[0][0]:
                if queue[0][1] == 'left':
                    queue[1][0].left = Node(val)
                else:
                    queue[1][0].right = Node(val)
                res = queue[1][0].val
                queue.clear()
                return res
            if val < queue[0][0].val:
                queue.insert(0,(queue[0][0].left,'left'))
            elif val > queue[0][0].val:
                queue.insert(0,(queue[0][0].right,'right'))

    def pre_order(self, cur):
        print(cur.val, end=' ')
        if cur.left:
            self.pre_order(cur.left)
        elif cur.right:
            self.pre_order(cur.right)

    def in_order(self, cur):
        if cur.left:
            self.in_order(cur.left)
        print(cur.val, end=' ')
        if cur.right:
            self.in_order(cur.right)

    def post_order(self, cur):
        if cur.left:
            self.post_order(cur.left)
        elif cur.right:
            self.post_order(cur.right)
        print(cur.val, end=' ')


if __name__ == '__main__':
    n = int(input())
    tree = BinaryTree()
    a = list(map(int,input().split()))
    for item in a:
        print(tree.insert(item))


```



[递归插入实现](../base/datastruct/binary_tree.py)

