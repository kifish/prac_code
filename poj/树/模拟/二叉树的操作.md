二叉树的操作
http://algorithm.openjudge.cn/algorithma/E/

1. 节点交换
把二叉树的两个节点交换。

2. 前驱询问
询问二叉树的一个节点对应的子树最左边的节点。

TLE 1446ms
```c
#include <iostream>
#include <iomanip>
#include <cmath>
#include <stdio.h>
#include <queue>
#include <cstring>
#include <set>
using namespace std;

struct Node {
	int parent;
	int l;
	int r;
	int leftmost;
};



int find_leftmost(int x, Node* node) {
	//返回最左节点的id
	if (node[x].leftmost != -1)
		return node[x].leftmost;
	if (node[x].l == -1) {
		return x;
	}
	int leftmost = find_leftmost(node[x].l, node);
	node[x].leftmost = leftmost;
	return leftmost;
}

Node node[100];

int main() {
	int t;
	cin >> t;
	int n, m;
	while (t--) {
		cin >> n >> m;
		//Node* node = new Node[n];
		memset(node, 0, sizeof(node));
		for (int i = 0; i < n; i++) {
			int x, y, z;
			cin >> x >> y >> z;
			node[x].l = y;
			node[x].r = z;
			node[x].leftmost = -1;
			if (y != -1)
				node[y].parent = x;
			if (z != -1)
				node[z].parent = x;
		}
		for (int i = 0; i < m; i++) {
			int type;
			cin >> type;
			if (type == 1) {
				int x, y;
				int is_x_left = 0;
				int is_y_left = 0;
				cin >> x >> y;
				int a = node[x].parent;
				int b = node[y].parent;
				if (node[a].l == x)
					is_x_left = 1;
				if (node[b].l == y)
					is_y_left = 2;

				if (is_x_left == 1) {
					node[a].l = y;
					node[a].leftmost = node[y].leftmost;
				}
				else
					node[a].r = y;

				if (is_y_left == 1) {
					node[b].l = x;
					node[b].leftmost = node[x].leftmost;
				}
				else
					node[b].r = x;

				int temp = node[x].parent;
				node[x].parent = node[y].parent;
				node[y].parent = temp;
			}
			else {
				int x;
				cin >> x;
				cout << find_leftmost(x, node) << endl;
			}
		}
		//delete[] node;
	}
	//while (1);
	return 0;
}


```


WA 43ms

```c
#include <iostream>
#include <iomanip>
#include <cmath>
#include <stdio.h>
#include <queue>
#include <cstring>
#include <set>
using namespace std;

struct Node {
	int parent;
	int l;
	int r;
	int leftmost;
};


int find_leftmost(int x, Node* node) {
	//返回最左节点的id
	if (node[x].leftmost != -1)//-1表示未知，否则返回0到n-1之间的值
		return node[x].leftmost;
	if (node[x].l == -1) {
		return x;
	}
	int leftmost = find_leftmost(node[x].l, node);
	node[x].leftmost = leftmost;
	return leftmost;
}

Node node[100];

int main() {
	int t;
	cin >> t;
	int n, m;
	while (t--) {
		cin >> n >> m;
		memset(node, 0, sizeof(node));
		while(n--) {
			int x, y, z;
			cin >> x >> y >> z;
			node[x].l = y;
			node[x].r = z;
			node[x].leftmost = -1;
			if (y != -1)
				node[y].parent = x;
			if (z != -1)
				node[z].parent = x;
		}
		while (m--) {
			int type;
			cin >> type;
			if (type == 1) {
				int x, y;
				int is_x_left = 0;
				int is_y_left = 0;
				cin >> x >> y;
				int a = node[x].parent;
				int b = node[y].parent;
				if (node[a].l == x)
					is_x_left = 1;
				if (node[b].l == y)
					is_y_left = 1;

				if (is_x_left == 1) {
					node[a].l = y;
					node[a].leftmost = node[y].leftmost;
				}
				else
					node[a].r = y;

				if (is_y_left == 1) {
					node[b].l = x;
					node[b].leftmost = node[x].leftmost;
				}
				else
					node[b].r = x;

				int temp = node[x].parent;
				node[x].parent = node[y].parent;
				node[y].parent = temp;
			}
			else {
				int x;
				cin >> x;
				cout << find_leftmost(x, node) << endl;
			}
		}
	}
	//while (1);
	return 0;
}


```
