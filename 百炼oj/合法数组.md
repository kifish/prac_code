




这种样例不够全面的题目，要自己先在纸上想几个样例

1 2 3 4 随便写4的全排列，样例如下：
1 2 3 4
1 3 2 4 
1 4 2 3
2 1 3 4
2 3 1 4 

反例证明：
2 3 1 4

这个序列其实是合法的。


WA
```C
#include <cstdio>
#include <string>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
#include <stack>
using namespace std;
vector<int> line;
stack<int> s;

int judge(vector<int> line,int n){
    int pre = 0;
    int start = 0;
    bool decreasing = false;
    if(n == 1){
        if(line[0] == 1)
            return true;
        else
            return false;
    }
    pre = line[0];
    int i = 1;
    for(;i < line.size();i++){
        if(line[i] < pre){
            if(line[i] == pre -1){
                if(decreasing)
                    continue;
                else{
                    decreasing = true;
                    start = i-1;
                }
            }
            else{
                if(decreasing){
                    decreasing = !decreasing;
                    reverse(line.begin()+start,line.begin()+i);
                }
            }
        }
        pre = line[i];
    }
    if(decreasing)
        reverse(line.begin()+start,line.begin()+i);
    int one_idx = 0;
    for(int i = 0;i<line.size();i++){
        if(line[i] == 1)
            one_idx = i;
    }
    int num = 1;
    while(num <= n){
        if(line[(one_idx + num -1)% n] == num){
            num++;
        }
        else
            return false;
    }
    return true;
}

/*
 合法的出栈序列是很多的，无法穷举。
 只能模拟。
 */
int main(){
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        line.clear();

        int tmp;
        int tmp2 = n;
        while(tmp2--) {
            cin>>tmp;
            line.push_back(tmp);
        }
        if(judge(line,n)){
            cout<<"yes"<<endl;
        }
        else{
            cout<<"no"<<endl;
        }
    }
    return 0;
}

```





https://www.linuxidc.com/Linux/2016-08/134743.htm

其实问题不复杂，过程就是 一些数从小到大入栈，但中间也可以出栈。
我们已知了出栈的情况，可以根据观察到的出栈的情况来模拟。
举例
3 2 4 1
我们见到了3，说明之前1 2 都已经入栈了，先push(1)再push(2)
再push(3)，此时 栈是非空的状态，并且，栈顶元素等于 出栈序列的第一元素，
则让栈顶元素出栈，
