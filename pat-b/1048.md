

这题有点坑，如果b的长度不够，前面要用0补后再加密。

```c
#include <iostream>
#include <iomanip>
#include <cmath>
#include <queue>
#include <cstring>
#include <string>
#include <vector>
#include <algorithm>
#include <map>
using namespace std;


char add(char a,char b,int type){
    char c;
    int res;
    if(type == 0){
        res = (b - '0') - (a - '0');
        if(res < 0) res += 10;
    }
    else{
        res = ((a - '0') + (b - '0')) % 13;
    }
    if(res == 10)
        c = 'J';
    else if(res == 11)
        c = 'Q';
    else if(res == 12)
        c = 'K';
    else
        c = res + '0';
    return c;
}

int main(){
    string a,b;
    cin>>a>>b;
    string res;
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());
    int i;
    for(i = 0;i<a.size() && i < b.size();i++){
        res += add(a[i], b[i],(i+1) % 2);
//        cout<<add(a[i], b[i],(i+1) % 2)<<endl;
    }
    if(i < b.size()) res += b.substr(i,b.size());
    else if(i < a.size()){
        for(;i< a.size();i++){
            res += add(a[i], '0',(i+1) % 2);
        }
    }
    reverse(res.begin(),res.end());
    cout<<res;
    return 0;
}
```